import os
import hashlib
import magic
import pandas as pd
import time
import pefile
from PyPDF2 import PdfReader
from PIL import Image
from PIL.ExifTags import TAGS
import olefile
import math

def extract_metadata_features(file_path):
    metadata_features = {}
    try:
        # Creation, modification, and access timestamps
        creation_time = os.path.getctime(file_path)
        modification_time = os.path.getmtime(file_path)
        access_time = os.path.getatime(file_path)
        metadata_features['creation_timestamp'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(creation_time))
        metadata_features['modification_timestamp'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(modification_time))
        metadata_features['access_timestamp'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(access_time))

        # Digital signatures presence or absence
        #metadata_features['digital_signature'] = has_digital_signature(file_path)
    except Exception as e:
        print("Metadata Features Error:", e)
    return metadata_features

def extract_text_features(file_path):
    text_features = {}
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
            content = file.read()
            # Define your keywords, phrases, or patterns here
            keywords = ['malware', 'virus', 'trojan', 'exploit']
            # Check presence of keywords in the content
            for keyword in keywords:
                text_features[keyword] = keyword in content
    except Exception as e:
        print("Text Features Error:", e)
    return text_features

def extract_opcode_histogram(file_path):
    opcode_histogram = {}
    try:
        with open(file_path, 'rb') as file:
            binary_content = file.read()
            pe = pefile.PE(data=binary_content)
            for section in pe.sections:
                for chunk in range(0, section.SizeOfRawData, 2):
                    opcode = binary_content[section.PointerToRawData + chunk: section.PointerToRawData + chunk + 2]
                    opcode_histogram[opcode] = opcode_histogram.get(opcode, 0) + 1
    except Exception as e:
        print("Opcode Histograms Error:", e)
    return opcode_histogram

def calculate_entropy(data):
    entropy = 0
    if data:
        data_size = len(data)
        frequency = {}
        for byte in data:
            frequency[byte] = frequency.get(byte, 0) + 1
        for count in frequency.values():
            probability = count / data_size
            entropy -= probability * math.log2(probability)
    return entropy

def extract_ole_objects(file_path):
    ole_objects = []
    try:
        ole = olefile.OleFileIO(file_path)
        for entry in ole.listdir():
            ole_objects.append(entry)
    except Exception as e:
        print("OLE Objects Error:", e)
    return ole_objects

def extract_streams_substreams(file_path):
    streams = []
    substreams = []
    try:
        ole = olefile.OleFileIO(file_path)
        for entry in ole.listdir():
            if ole.isdir(entry):
                substreams.extend(ole.listdir(entry))
            else:
                streams.append(entry)
    except Exception as e:
        print("Streams and Substreams Error:", e)
    return streams, substreams

def extract_byte_sequences(file_path):
    byte_sequences = []
    try:
        with open(file_path, 'rb') as file:
            byte = file.read(1)
            while byte:
                byte_sequences.append(byte)
                byte = file.read(1)
    except Exception as e:
        print("Error:", e)
    return byte_sequences

def extract_imported_functions(file_path):
    imported_functions = []
    try:
        pe = pefile.PE(file_path)
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode('utf-8')
            for imp in entry.imports:
                if imp.name:
                    imported_functions.append((dll_name, imp.name.decode('utf-8')))
    except Exception as e:
        print("Error:", e)
    return imported_functions


def extract_file_features(file_path):
    features = {}

    # Basic file attributes
    features['file_size'] = os.path.getsize(file_path)

    # Calculate hash
    hash_md5 = hashlib.md5()
    with open(file_path, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b''):
            hash_md5.update(chunk)
    features['md5_hash'] = hash_md5.hexdigest()

    # Extract metadata based on file type
    file_type = magic.Magic()
    detected_type = file_type.from_file(file_path)
    features['Metadata'] = file_type.from_file(file_path)

    metadata_features = extract_metadata_features(file_path)
    features.update(metadata_features)

    #Finding out the time stamps of the file and wether or not it has changed and exact timestamps
    ti_m = os.path.getmtime(file_path)
    m_ti = time.ctime(ti_m)
    # Using the timestamp string to create a time object/structure
    t_obj = time.strptime(m_ti)
    # Transforming the time object to a timestamp of ISO 8601 format
    T_stamp = time.strftime("%Y-%m-%d %H:%M:%S", t_obj)
    timestamp = f"{T_stamp}"
    features['last_modified_timestamp'] = timestamp

    text_features = extract_text_features(file_path)
    features.update(text_features)

    # If the detected file type is an EXE file, extract opcode histograms
    if 'PE32' in detected_type or 'PE32+' in detected_type:
        try:
            
            opcode_histogram = extract_opcode_histogram(file_path)
            #features['opcode_histogram'] = opcode_histogram

            # Extract imported functions and byte sequences
            imported_functions = extract_imported_functions(file_path)
            # features['imported_functions'] = imported_functions

            # Calculate entropy of byte sequences
            byte_sequences = extract_byte_sequences(file_path)
            # features['byte_sequences'] = byte_sequences

            features['byte_sequences_entropy'] = calculate_entropy(byte_sequences)
        
        except Exception as e:
            print("Error:", e)


    # If the detected file type is PDF, extract PDF-specific features
    elif 'PDF document' in detected_type:
        
        try:
            with open(file_path, 'rb') as file:
                pdf_reader = PdfReader(file)
                features['num_pages'] = len(pdf_reader.pages)

                # Extract document properties
                document_info = pdf_reader.metadata
                for key, value in document_info.items():
                    features[f'pdf_{key.lower().replace(" ", "_")}'] = value

                # Extract byte sequences
                byte_sequences = []
                for page_num in range(features['num_pages']):
                    page = pdf_reader.pages[page_num]
                    page_content = page.extract_text().encode('utf-8', 'ignore')
                    byte_sequences.extend(page_content)
                # features['byte_sequences'] = byte_sequences

                # Extract embedded objects count and types
                embedded_objects_count = 0
                embedded_objects_types = set()
                for page_num in range(features['num_pages']):
                    
                    page = pdf_reader.pages[page_num]
                    if '/XObject' in page['/Resources']:
                        xobjects = page['/Resources']['/XObject'].keys()
                        for obj in xobjects:
                            obj_type = page['/Resources']['/XObject'][obj]['/Subtype']
                            embedded_objects_types.add(obj_type)
                            embedded_objects_count += 1

                features['embedded_objects_count'] = embedded_objects_count
                features['embedded_objects_types'] = list(embedded_objects_types)

                with open(file_path, 'rb') as file:
                    pdf_reader = PdfReader(file)
                    byte_sequences = []
                    for page_num in range(len(pdf_reader.pages)):
                        page = pdf_reader.pages[page_num]
                        page_content = page.extract_text().encode('utf-8', 'ignore')
                        byte_sequences.extend(page_content)
                    # Calculate entropy of byte sequences
                    features['byte_sequences_entropy'] = calculate_entropy(byte_sequences)

        except Exception as e:
            print("PDF Error:", e)
            features['num_pages'] = 0


    # If the detected file type is an image, extract image-specific metadata
    elif 'image' in detected_type:
        try:
            image = Image.open(file_path)

            # Extract basic image attributes
            image_info = image.info
            for key, value in image_info.items():
                features[f'image_{key.lower().replace(" ", "_")}'] = value

            # Extract EXIF data
            exif_data = image._getexif()
            if exif_data:
                for tag, value in exif_data.items():
                    tag_name = TAGS.get(tag, tag)
                    features[f'image_exif_{tag_name.lower().replace(" ", "_")}'] = value

            # Extract byte sequences
            with open(file_path, 'rb') as file:
                byte_sequences = file.read()
                # Calculate entropy of byte sequences
                features['byte_sequences_entropy'] = calculate_entropy(byte_sequences)

        except Exception as e:
            print("Image Error:", e)


    elif 'ole' in detected_type:
        try:
            # Extract streams and substreams
            streams, substreams = extract_streams_substreams(file_path)
            features['streams'] = streams
            features['substreams'] = substreams

        except Exception as e:
            print("Image Error:", e)

    return features

def main():
    file_path = "/Users/brentdoyle/Documents/GitHub/non-malware/executable non-malware files/0a8deb24eef193e13c691190758c349776eab1cd65fba7b5dae77c7ee9fcc906.exe"
    feat = extract_file_features(file_path)
    
    # Print all extracted features
    print("Extracted features:")
    for key, value in feat.items():
        print(f"{key}: {value}")
    

if __name__ == "__main__":
    main()
