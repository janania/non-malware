import os
import hashlib
import magic
import subprocess
import pefile
from PyPDF2 import PdfReader
from PIL import Image
from PIL.ExifTags import TAGS
from capstone import Cs, CS_MODE_32

def extract_embedded_objects(file_path):
    embedded_objects = []

    try:
        pe = pefile.PE(file_path)

        # Iterate over the data directories
        for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries:
            # Check if the entry contains any embedded objects
            if entry.name is not None:
                # Extract the type and name of the embedded object
                embedded_type = entry.name.__str__()
                embedded_name = entry.directory.entries[0].name.__str__()

                embedded_objects.append((embedded_type, embedded_name))

    except Exception as e:
        print("Error:", e)

    return embedded_objects

def check_digital_signature(file_path):
    try:
        output = subprocess.check_output(['sigcheck', '-q', '-nobanner', file_path])
        return b'Signed:' in output
    except subprocess.CalledProcessError:
        return False

def extract_byte_sequences(file_path):
    byte_sequences = []
    try:
        with open(file_path, 'rb') as file:
            byte_sequences = list(file.read())
    except Exception as e:
        print("Error:", e)
    
    return byte_sequences
    
def extract_imported_functions(file_path):
    imported_functions = []
    try:
        pe = pefile.PE(file_path)
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode('utf-8')
            for imp in entry.imports:
                if imp.name:
                    imported_functions.append((dll_name, imp.name.decode('utf-8')))
    except Exception as e:
        print("Error:", e)
    
    return imported_functions

def extract_file_features(file_path):
    features = {}

    # Basic file attributes
    features['file_size'] = os.path.getsize(file_path)

    # Calculate hash
    hash_md5 = hashlib.md5()
    with open(file_path, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b''):
            hash_md5.update(chunk)
    features['md5_hash'] = hash_md5.hexdigest()

    # Extract metadata based on file type
    file_type = magic.Magic()
    detected_type = file_type.from_file(file_path)
    #print(detected_type)

    # If the detected file type is an EXE file, extract opcode histograms
    if 'PE32' in detected_type or 'PE32+' in detected_type:
        print("exe file detected")
        try:
            with open(file_path, 'rb') as file:
                binary_content = file.read()
                opcode_histogram = {}

                # Disassemble the binary content
                md = Cs(Cs.ARCH_X86, CS_MODE_32)
                for instruction in md.disasm(binary_content, 0x1000):
                    opcode = instruction.mnemonic
                    if opcode in opcode_histogram:
                        opcode_histogram[opcode] += 1
                    else:
                        opcode_histogram[opcode] = 1

                features['opcode_histogram'] = opcode_histogram

            # Extract imported functions
            imported_functions = extract_imported_functions(file_path)
            features['imported_functions'] = imported_functions

            # Extract byte sequences
            byte_sequences = extract_byte_sequences(file_path)
            features['byte_sequences'] = byte_sequences

            # Check for digital signature
            features['digital_signature'] = check_digital_signature(file_path)

            # Extract embedded objects
            embedded_objects = extract_embedded_objects(file_path)
            features['embedded_objects'] = embedded_objects
        
        except Exception as e:
            print("Error:", e)
            
    # If the detected file type is PDF, extract PDF-specific features
    elif 'PDF document' in detected_type:
        
        try:
            with open(file_path, 'rb') as file:
                pdf_reader = PdfReader(file)
                
                features['num_pages'] = len(pdf_reader.pages)

                # Extract document properties
                document_info = pdf_reader.metadata
                for key, value in document_info.items():
                    features[f'pdf_{key.lower().replace(" ", "_")}'] = value


                print(features[f'pdf_{key.lower().replace(" ", "_")}'])

                # Extract byte sequences
                byte_sequences = []
                for page_num in range(features['num_pages']):
                    #print("entered byte")
                    page = pdf_reader.pages[page_num]
                    page_content = page.extract_text().encode('utf-8', 'ignore')
                    byte_sequences.extend(page_content)
                features['byte_sequences'] = byte_sequences

                #print(features['byte_sequences'])

                # Extract embedded objects count and types
                embedded_objects_count = 0
                embedded_objects_types = set()
                for page_num in range(features['num_pages']):
                    
                    page = pdf_reader.pages[page_num]
                    if '/XObject' in page['/Resources']:
                        xobjects = page['/Resources']['/XObject'].keys()
                        for obj in xobjects:
                            obj_type = page['/Resources']['/XObject'][obj]['/Subtype']
                            embedded_objects_types.add(obj_type)
                            embedded_objects_count += 1

                features['embedded_objects_count'] = embedded_objects_count
                features['embedded_objects_types'] = list(embedded_objects_types)

                print(features['embedded_objects_types'])

        except Exception as e:
            print("PDF Error:", e)
            features['num_pages'] = 0


    # If the detected file type is an image, extract image-specific metadata
    elif 'image' in detected_type:
        try:
            image = Image.open(file_path)

            # Extract basic image attributes
            image_info = image.info
            for key, value in image_info.items():
                features[f'image_{key.lower().replace(" ", "_")}'] = value

            # Extract EXIF data
            exif_data = image._getexif()
            if exif_data:
                for tag, value in exif_data.items():
                    tag_name = TAGS.get(tag, tag)
                    features[f'image_exif_{tag_name.lower().replace(" ", "_")}'] = value
        except Exception as e:
            print("Image Error:", e)

    return features

def main():
    file_path = "test_file.exe"  
    feat = extract_file_features(file_path)
    print(feat)

if __name__ == "__main__":
    main()
